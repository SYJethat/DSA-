# 🧠 DSA Roadmap: Beginner to Advanced  
*With Timelines, Topic Explanations, and Study Tips*

---

## 📑 Index

1. [Beginner Level (2–3 weeks)](#1-beginner-level-2-3-weeks)
2. [Intermediate Level (3–4 weeks)](#2-intermediate-level-3-4-weeks)
3. [Advanced Level (5–6 weeks)](#3-advanced-level-5-6-weeks)
4. [Expert Level (3–4 weeks)](#4-expert-level-3-4-weeks)
5. [Bonus Topics (2 weeks)](#5-bonus-topics-2-weeks)
6. [Study Strategy & Success Tips](#6-study-strategy--success-tips)

---

## 1. ✅ Beginner Level (⏳ 2–3 Weeks)

> Build fundamental understanding of data structures and how computers solve problems.

### 📚 Topics:

- **Time and Space Complexity**  
  Learn how to analyze code performance using Big O, Ω, Θ notation. Understand best, worst, and average cases.

- **Arrays & Strings**  
  Master basic operations like insert, delete, search, reverse, sliding window problems, and common string manipulations.

- **Linked Lists**  
  Implement singly and doubly linked lists from scratch. Focus on reversing, cycle detection, and merge lists.

- **Stacks and Queues**  
  Learn LIFO/FIFO principles. Use for problems like balanced parentheses, min stack, and sliding window maximum.

- **Basic Recursion**  
  Understand function calls, base cases, and recursion trees with problems like factorial, sum of digits, and power.

- **Basic Math**  
  Learn GCD, LCM, Sieve of Eratosthenes, Prime check, Bit manipulation basics (XOR, AND, OR, Left/Right shifts).

---

## 2. 🟡 Intermediate Level (⏳ 3–4 Weeks)

> Learn problem-solving techniques and patterns used in coding rounds.

### 📚 Topics:

- **Binary Search**  
  Learn to apply binary search on sorted arrays and search space. Practice peak element, sqrt, allocation problems.

- **Sorting Algorithms**  
  Understand Merge Sort, Quick Sort, and Count Sort. Learn time/space trade-offs and when to use which.

- **Hashing**  
  Use hash maps and sets to solve frequency-based problems, two-sum, anagrams, and longest consecutive sequence.

- **Two Pointers**  
  Useful for searching pairs/triplets, removing duplicates, merging arrays, and solving sorted array problems.

- **Sliding Window**  
  Essential for fixed/variable-length subarrays: longest substring, max in window, anagram check.

- **Prefix Sum & Difference Array**  
  Preprocessing technique to answer range sum or updates efficiently.

- **Backtracking Basics**  
  Understand how to explore all possibilities: Subsets, Permutations, N-Queens, Rat in a Maze.

---

## 3. 🟢 Advanced Level (⏳ 5–6 Weeks)

> Tackle data structures and algorithms behind real systems and applications.

### 📚 Topics:

- **Trees & Binary Trees**  
  Depth/Breadth traversal, recursion in trees, level order traversal, diameter, height, and leaf paths.

- **Binary Search Tree (BST)**  
  Insertion, deletion, search, floor/ceil, validate BST, in-order predecessor/successor.

- **Heaps & Priority Queues**  
  Use Min/Max Heap for top-K elements, stream processing, and scheduling tasks.

- **Greedy Algorithms**  
  Pick locally optimal solutions. Study activity selection, coin change (greedy), job scheduling.

- **Dynamic Programming (DP)**  
  Bottom-up and top-down approaches. Learn 0/1 Knapsack, LCS, LIS, min/max path, DP on subsets.

- **Tree & Matrix DP**  
  Problems like “maximum path sum in binary tree” or “unique paths” and “minimum falling path sum.”

---

## 4. 🔵 Expert Level (⏳ 3–4 Weeks)

> Core CS algorithms tested in top tech companies (FAANG).

### 📚 Topics:

- **Graphs**  
  Represent with adjacency list/matrix. Learn BFS/DFS, detect cycle, connected components.

- **Union-Find (Disjoint Set)**  
  For detecting cycles and connectivity in graphs using path compression and union by rank.

- **Shortest Path Algorithms**  
  Dijkstra (greedy), Bellman-Ford (for negative weights), Floyd-Warshall (all-pairs shortest path).

- **Minimum Spanning Tree (MST)**  
  Kruskal and Prim algorithms to build MST for network design problems.

- **Tries & Suffix Trees**  
  Efficient searching in dictionaries. Used in autocomplete, spell-check, and prefix matching.

- **Segment Trees & Fenwick Trees**  
  Solve range queries like sum, min, max with efficient update/query operations.

- **Advanced DP & Bitmasking**  
  Solve problems with multiple changing parameters or states.

- **String Matching Algorithms**  
  Learn KMP (prefix function), Rabin-Karp (hashing), and Z-algorithm for pattern matching.

---

## 5. 📘 Bonus Topics (⏳ 2 Weeks)

> Advanced and niche techniques for optimization and competitions.

### 📚 Topics:

- **Monotonic Stack/Queue**  
  Solve histogram, stock span, and next greater/smaller problems.

- **Mo’s Algorithm**  
  Efficient way to solve offline range query problems in O((N + Q) * sqrt(N)).

- **Game Theory**  
  Understand Grundy numbers and strategies in games like Nim.

- **Number Theory**  
  Euler’s theorem, Chinese Remainder Theorem, Modular Inverse, fast exponentiation.

- **Heavy-Light Decomposition**  
  For breaking trees into chains to solve path queries efficiently.

---

## 6. 🧭 Study Strategy & Success Tips

### ⏱️ **Daily Plan (2–4 hours/day)**

| Time          | Task                                         |
|---------------|----------------------------------------------|
| 30–45 minutes | Learn theory / watch concept video           |
| 1–2 hours     | Practice 3–5 DSA problems                    |
| 15–30 minutes | Revise mistakes, note patterns               |
| Weekly        | Take mock test or timed problem set          |

---

### ✅ Checklist for Success

- [ ] Follow roadmap with daily/weekly targets  
- [ ] Solve 10–20 problems per topic from LeetCode or GFG  
- [ ] Track weak areas and re-practice weekly  
- [ ] Attempt mock interviews (Pramp, InterviewBit, friends)  
- [ ] Participate in contests (Codeforces, AtCoder, LeetCode Weekly)

---
